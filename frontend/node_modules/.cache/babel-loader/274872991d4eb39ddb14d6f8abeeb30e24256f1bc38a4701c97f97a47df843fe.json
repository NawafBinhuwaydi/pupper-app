{"ast":null,"code":"import _objectSpread from \"/home/nawaf/aws-project/pupper-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ConsoleLogger } from '../../../Logger/ConsoleLogger.mjs';\nimport '../../../types/errors.mjs';\nimport '../../../errors/errorHelpers.mjs';\nimport '../../../utils/getClientInfo/getClientInfo.mjs';\nimport '../../../utils/retry/retry.mjs';\nimport '../../../parseAWSExports.mjs';\nimport 'uuid';\nimport '../../../singleton/Auth/utils/errorHelpers.mjs';\nimport '@aws-crypto/sha256-js';\nimport '@smithy/util-hex-encoding';\nimport { haveCredentialsChanged } from '../../../utils/haveCredentialsChanged.mjs';\nimport '../../../Platform/index.mjs';\nimport '../../../Platform/types.mjs';\nimport '../../../BackgroundProcessManager/types.mjs';\nimport '../../../Reachability/Reachability.mjs';\nimport '../../../Hub/index.mjs';\nimport '../../../utils/sessionListener/index.mjs';\nimport { putEvents } from '../../../awsClients/pinpoint/putEvents.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('PinpointEventBuffer');\nconst RETRYABLE_CODES = [429, 500];\nconst ACCEPTED_CODES = [202];\nclass PinpointEventBuffer {\n  constructor(config) {\n    this._interval = undefined;\n    this._pause = false;\n    this._flush = false;\n    this._buffer = [];\n    this._config = config;\n    this._sendBatch = this._sendBatch.bind(this);\n    this._startLoop();\n  }\n  push(event) {\n    if (this._buffer.length >= this._config.bufferSize) {\n      logger.debug('Exceeded Pinpoint event buffer limits, event dropped.', {\n        eventId: event.eventId\n      });\n      return;\n    }\n    this._buffer.push({\n      [event.eventId]: event\n    });\n  }\n  pause() {\n    this._pause = true;\n  }\n  resume() {\n    this._pause = false;\n  }\n  flush() {\n    this._flush = true;\n  }\n  identityHasChanged(identityId) {\n    return this._config.identityId !== identityId;\n  }\n  haveCredentialsChanged(credentials) {\n    return haveCredentialsChanged(this._config.credentials, credentials);\n  }\n  flushAll() {\n    this._putEvents(this._buffer.splice(0, this._buffer.length));\n  }\n  _startLoop() {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    const {\n      flushInterval\n    } = this._config;\n    this._interval = setInterval(this._sendBatch, flushInterval);\n  }\n  _sendBatch() {\n    const bufferLength = this._buffer.length;\n    if (this._flush && !bufferLength && this._interval) {\n      clearInterval(this._interval);\n    }\n    if (this._pause || !bufferLength || false) {\n      return;\n    }\n    const {\n      flushSize\n    } = this._config;\n    const batchSize = Math.min(flushSize, bufferLength);\n    const bufferSubset = this._buffer.splice(0, batchSize);\n    this._putEvents(bufferSubset);\n  }\n  async _putEvents(buffer) {\n    const eventMap = this._bufferToMap(buffer);\n    const batchEventParams = this._generateBatchEventParams(eventMap);\n    try {\n      const {\n        credentials,\n        region,\n        userAgentValue\n      } = this._config;\n      const data = await putEvents({\n        credentials,\n        region,\n        userAgentValue\n      }, batchEventParams);\n      this._processPutEventsSuccessResponse(data, eventMap);\n    } catch (err) {\n      this._handlePutEventsFailure(err, eventMap);\n    }\n  }\n  _generateBatchEventParams(eventMap) {\n    const batchItem = {};\n    Object.values(eventMap).forEach(item => {\n      var _batchItem$endpointId, _batchItem$endpointId2;\n      const {\n        event,\n        timestamp,\n        endpointId,\n        eventId,\n        session\n      } = item;\n      const {\n        name,\n        attributes,\n        metrics\n      } = event;\n      batchItem[endpointId] = {\n        Endpoint: _objectSpread({}, (_batchItem$endpointId = batchItem[endpointId]) === null || _batchItem$endpointId === void 0 ? void 0 : _batchItem$endpointId.Endpoint),\n        Events: _objectSpread(_objectSpread({}, (_batchItem$endpointId2 = batchItem[endpointId]) === null || _batchItem$endpointId2 === void 0 ? void 0 : _batchItem$endpointId2.Events), {}, {\n          [eventId]: {\n            EventType: name,\n            Timestamp: new Date(timestamp).toISOString(),\n            Attributes: attributes,\n            Metrics: metrics,\n            Session: session\n          }\n        })\n      };\n    });\n    return {\n      ApplicationId: this._config.appId,\n      EventsRequest: {\n        BatchItem: batchItem\n      }\n    };\n  }\n  _handlePutEventsFailure(err, eventMap) {\n    logger.debug('putEvents call to Pinpoint failed.', err);\n    const statusCode = err.$metadata && err.$metadata.httpStatusCode;\n    if (RETRYABLE_CODES.includes(statusCode)) {\n      const retryableEvents = Object.values(eventMap);\n      this._retry(retryableEvents);\n    }\n  }\n  _processPutEventsSuccessResponse(data, eventMap) {\n    var _data$EventsResponse;\n    const {\n      Results = {}\n    } = (_data$EventsResponse = data.EventsResponse) !== null && _data$EventsResponse !== void 0 ? _data$EventsResponse : {};\n    const retryableEvents = [];\n    Object.entries(Results).forEach(_ref => {\n      var _endpointValues$Event;\n      let [_, endpointValues] = _ref;\n      const responses = (_endpointValues$Event = endpointValues.EventsItemResponse) !== null && _endpointValues$Event !== void 0 ? _endpointValues$Event : {};\n      Object.entries(responses).forEach(_ref2 => {\n        let [eventId, eventValues] = _ref2;\n        const eventObject = eventMap[eventId];\n        if (!eventObject) {\n          return;\n        }\n        const {\n          StatusCode,\n          Message\n        } = eventValues !== null && eventValues !== void 0 ? eventValues : {};\n        if (StatusCode && ACCEPTED_CODES.includes(StatusCode)) {\n          return;\n        }\n        if (StatusCode && RETRYABLE_CODES.includes(StatusCode)) {\n          retryableEvents.push(eventObject);\n          return;\n        }\n        const {\n          name\n        } = eventObject.event;\n        logger.warn('Pinpoint event failed to send.', {\n          eventId,\n          name,\n          message: Message\n        });\n      });\n    });\n    if (retryableEvents.length) {\n      this._retry(retryableEvents);\n    }\n  }\n  _retry(retryableEvents) {\n    // retryable events that haven't reached the resendLimit\n    const eligibleEvents = [];\n    retryableEvents.forEach(bufferedEvent => {\n      const {\n        eventId\n      } = bufferedEvent;\n      const {\n        name\n      } = bufferedEvent.event;\n      if (bufferedEvent.resendLimit-- > 0) {\n        logger.debug('Resending event.', {\n          eventId,\n          name,\n          remainingAttempts: bufferedEvent.resendLimit\n        });\n        eligibleEvents.push({\n          [eventId]: bufferedEvent\n        });\n        return;\n      }\n      logger.debug('No retry attempts remaining for event.', {\n        eventId,\n        name\n      });\n    });\n    // add the events to the front of the buffer\n    this._buffer.unshift(...eligibleEvents);\n  }\n  _bufferToMap(buffer) {\n    return buffer.reduce((acc, curVal) => {\n      const [[key, value]] = Object.entries(curVal);\n      acc[key] = value;\n      return acc;\n    }, {});\n  }\n}\nexport { PinpointEventBuffer };\n//# sourceMappingURL=PinpointEventBuffer.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}