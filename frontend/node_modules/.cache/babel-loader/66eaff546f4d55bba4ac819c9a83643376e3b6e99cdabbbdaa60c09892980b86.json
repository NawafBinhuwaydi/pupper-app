{"ast":null,"code":"import { ConsoleLogger } from '../Logger/ConsoleLogger.mjs';\nimport { defaultConfig, currentSizeKey } from './constants.mjs';\nimport { getCurrentSizeKey, getCurrentTime, getByteLength } from './utils/cacheHelpers.mjs';\nimport { assert, CacheErrorCode } from './utils/errorHelpers.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nclass StorageCacheCommon {\n  /**\n   * Initialize the cache\n   *\n   * @param config - Custom configuration for this instance.\n   */\n  constructor({\n    config,\n    keyValueStorage\n  }) {\n    this.config = {\n      ...defaultConfig,\n      ...config\n    };\n    this.keyValueStorage = keyValueStorage;\n    this.sanitizeConfig();\n  }\n  getModuleName() {\n    return 'Cache';\n  }\n  /**\n   * Set custom configuration for the cache instance.\n   *\n   * @param config - customized configuration (without keyPrefix, which can't be changed)\n   *\n   * @return - the current configuration\n   */\n  configure(config) {\n    if (config) {\n      if (config.keyPrefix) {\n        logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n      }\n      this.config = {\n        ...this.config,\n        ...config\n      };\n    }\n    this.sanitizeConfig();\n    return this.config;\n  }\n  /**\n   * return the current size of the cache\n   * @return {Promise}\n   */\n  async getCurrentCacheSize() {\n    let size = await this.getStorage().getItem(getCurrentSizeKey(this.config.keyPrefix));\n    if (!size) {\n      await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), '0');\n      size = '0';\n    }\n    return Number(size);\n  }\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   *\n   * @return {Promise}\n   */\n  async setItem(key, value, options) {\n    logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n    if (!key || key === currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n      return;\n    }\n    if (typeof value === 'undefined') {\n      logger.warn(`The value of item should not be undefined!`);\n      return;\n    }\n    const cacheItemOptions = {\n      priority: options?.priority !== undefined ? options.priority : this.config.defaultPriority,\n      expires: options?.expires !== undefined ? options.expires : this.config.defaultTTL + getCurrentTime()\n    };\n    if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n      logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n      return;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n    // check whether this item is too big;\n    if (item.byteSize > this.config.itemMaxSize) {\n      logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n      return;\n    }\n    try {\n      // first look into the storage, if it exists, delete it.\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n      // check whether the cache is full\n      if (await this.isCacheFull(item.byteSize)) {\n        const validKeys = await this.clearInvalidAndGetRemainingKeys();\n        if (await this.isCacheFull(item.byteSize)) {\n          const sizeToPop = await this.sizeToPop(item.byteSize);\n          await this.popOutItems(validKeys, sizeToPop);\n        }\n      }\n      // put item in the cache\n      return this.setCacheItem(prefixedKey, item);\n    } catch (e) {\n      logger.warn(`setItem failed! ${e}`);\n    }\n  }\n  /**\n   * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with AsyncStorage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return {Promise} - return a promise resolves to be the value of the item\n   */\n  async getItem(key, options) {\n    logger.debug(`Get item: key is ${key} with options ${options}`);\n    let cached;\n    if (!key || key === currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n      return null;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    try {\n      cached = await this.getStorage().getItem(prefixedKey);\n      if (cached != null) {\n        if (await this.isExpired(prefixedKey)) {\n          // if expired, remove that item and return null\n          await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n        } else {\n          // if not expired, update its visitedTime and return the value\n          const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n          return item.data;\n        }\n      }\n      if (options?.callback) {\n        const val = options.callback();\n        if (val !== null) {\n          await this.setItem(key, val, options);\n        }\n        return val;\n      }\n      return null;\n    } catch (e) {\n      logger.warn(`getItem failed! ${e}`);\n      return null;\n    }\n  }\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with AsyncStorage\n   * @param {String} key - the key of the item\n   * @return {Promise}\n   */\n  async removeItem(key) {\n    logger.debug(`Remove item: key is ${key}`);\n    if (!key || key === currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n      return;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    try {\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n    } catch (e) {\n      logger.warn(`removeItem failed! ${e}`);\n    }\n  }\n  /**\n   * Return all the keys owned by this cache.\n   * Will return an empty array if error occurred.\n   *\n   * @return {Promise}\n   */\n  async getAllKeys() {\n    try {\n      return await this.getAllCacheKeys();\n    } catch (e) {\n      logger.warn(`getAllkeys failed! ${e}`);\n      return [];\n    }\n  }\n  getStorage() {\n    return this.keyValueStorage;\n  }\n  /**\n   * check whether item is expired\n   *\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  async isExpired(key) {\n    const text = await this.getStorage().getItem(key);\n    assert(text !== null, CacheErrorCode.NoCacheItem, `Key: ${key}`);\n    const item = JSON.parse(text);\n    if (getCurrentTime() >= item.expires) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * delete item from cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  async removeCacheItem(prefixedKey, size) {\n    const item = await this.getStorage().getItem(prefixedKey);\n    assert(item !== null, CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n    const itemSize = size ?? JSON.parse(item).byteSize;\n    // first try to update the current size of the cache\n    await this.decreaseCurrentSizeInBytes(itemSize);\n    // try to remove the item from cache\n    try {\n      await this.getStorage().removeItem(prefixedKey);\n    } catch (removeItemError) {\n      // if some error happened, we need to rollback the current size\n      await this.increaseCurrentSizeInBytes(itemSize);\n      logger.error(`Failed to remove item: ${removeItemError}`);\n    }\n  }\n  /**\n   * produce a JSON object with meta-data and data value\n   * @param value - the value of the item\n   * @param options - optional, the specified meta-data\n   *\n   * @return - the item which has the meta-data and the value\n   */\n  fillCacheItem(key, value, options) {\n    const item = {\n      key,\n      data: value,\n      timestamp: getCurrentTime(),\n      visitedTime: getCurrentTime(),\n      priority: options.priority ?? 0,\n      expires: options.expires ?? 0,\n      type: typeof value,\n      byteSize: 0\n    };\n    // calculate byte size\n    item.byteSize = getByteLength(JSON.stringify(item));\n    // re-calculate using cache item with updated byteSize property\n    item.byteSize = getByteLength(JSON.stringify(item));\n    return item;\n  }\n  sanitizeConfig() {\n    if (this.config.itemMaxSize > this.config.capacityInBytes) {\n      logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n      this.config.itemMaxSize = defaultConfig.itemMaxSize;\n    }\n    if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n      logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n      this.config.defaultPriority = defaultConfig.defaultPriority;\n    }\n    if (Number(this.config.warningThreshold) > 1 || Number(this.config.warningThreshold) < 0) {\n      logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n      this.config.warningThreshold = defaultConfig.warningThreshold;\n    }\n    // Set 5MB limit\n    const cacheLimit = 5 * 1024 * 1024;\n    if (this.config.capacityInBytes > cacheLimit) {\n      logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n      this.config.capacityInBytes = defaultConfig.capacityInBytes;\n    }\n  }\n  /**\n   * increase current size of the cache\n   *\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  async increaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size + amount).toString());\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  async decreaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size - amount).toString());\n  }\n  /**\n   * update the visited time if item has been visited\n   *\n   * @param item - the item which need to be updated\n   * @param prefixedKey - the key of the item\n   *\n   * @return the updated item\n   */\n  async updateVisitedTime(item, prefixedKey) {\n    item.visitedTime = getCurrentTime();\n    await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    return item;\n  }\n  /**\n   * put item into cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  async setCacheItem(prefixedKey, item) {\n    // first try to update the current size of the cache.\n    await this.increaseCurrentSizeInBytes(item.byteSize);\n    // try to add the item into cache\n    try {\n      await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    } catch (setItemErr) {\n      // if some error happened, we need to rollback the current size\n      await this.decreaseCurrentSizeInBytes(item.byteSize);\n      logger.error(`Failed to set item ${setItemErr}`);\n    }\n  }\n  /**\n   * total space needed when poping out items\n   *\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  async sizeToPop(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n    const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n    return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n  }\n  /**\n   * see whether cache is full\n   *\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  async isCacheFull(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    return itemSize + cur > this.config.capacityInBytes;\n  }\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  async popOutItems(keys, sizeToPop) {\n    const items = [];\n    let remainedSize = sizeToPop;\n    for (const key of keys) {\n      const val = await this.getStorage().getItem(key);\n      if (val != null) {\n        const item = JSON.parse(val);\n        items.push(item);\n      }\n    }\n    // first compare priority\n    // then compare visited time\n    items.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      } else {\n        if (a.visitedTime < b.visitedTime) {\n          return -1;\n        } else return 1;\n      }\n    });\n    for (const item of items) {\n      // pop out items until we have enough room for new item\n      await this.removeCacheItem(item.key, item.byteSize);\n      remainedSize -= item.byteSize;\n      if (remainedSize <= 0) {\n        return;\n      }\n    }\n  }\n  /**\n   * Scan the storage and combine the following operations for efficiency\n   *   1. Clear out all expired keys owned by this cache, not including the size key.\n   *   2. Return the remaining keys.\n   *\n   * @return The remaining valid keys\n   */\n  async clearInvalidAndGetRemainingKeys() {\n    const remainingKeys = [];\n    const keys = await this.getAllCacheKeys({\n      omitSizeKey: true\n    });\n    for (const key of keys) {\n      if (await this.isExpired(key)) {\n        await this.removeCacheItem(key);\n      } else {\n        remainingKeys.push(key);\n      }\n    }\n    return remainingKeys;\n  }\n  /**\n   * clear the entire cache\n   * The cache will abort and output a warning if error occurs\n   * @return {Promise}\n   */\n  async clear() {\n    logger.debug(`Clear Cache`);\n    try {\n      const keys = await this.getAllKeys();\n      for (const key of keys) {\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        await this.getStorage().removeItem(prefixedKey);\n      }\n    } catch (e) {\n      logger.warn(`clear failed! ${e}`);\n    }\n  }\n}\nexport { StorageCacheCommon };\n//# sourceMappingURL=StorageCacheCommon.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}