{"ast":null,"code":"import { AuthError } from '../../../../../errors/AuthError.mjs';\nimport { textEncoder } from '../../textEncoder/index.mjs';\nimport BigInteger from '../BigInteger/BigInteger.mjs';\nimport { calculateS } from '../calculate/calculateS.mjs';\nimport { calculateU } from '../calculate/calculateU.mjs';\nimport { getBytesFromHex } from '../getBytesFromHex.mjs';\nimport { getHashFromData } from '../getHashFromData.mjs';\nimport { getHashFromHex } from '../getHashFromHex.mjs';\nimport { getHexFromBytes } from '../getHexFromBytes.mjs';\nimport { getHkdfKey } from '../getHkdfKey.mjs';\nimport { getPaddedHex } from '../getPaddedHex.mjs';\nimport { getRandomBytes } from '../getRandomBytes.mjs';\nimport { getRandomString } from '../getRandomString.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/** @class */\nclass AuthenticationHelper {\n  constructor({\n    userPoolName,\n    a,\n    g,\n    A,\n    N\n  }) {\n    this.encoder = textEncoder;\n    this.userPoolName = userPoolName;\n    this.a = a;\n    this.g = g;\n    this.A = A;\n    this.N = N;\n    this.k = new BigInteger(getHashFromHex(`${getPaddedHex(N)}${getPaddedHex(g)}`), 16);\n  }\n  /**\n   * @returns {string} Generated random value included in password hash.\n   */\n  getRandomPassword() {\n    if (!this.randomPassword) {\n      throw new AuthError({\n        name: 'EmptyBigIntegerRandomPassword',\n        message: 'random password is empty'\n      });\n    }\n    return this.randomPassword;\n  }\n  /**\n   * @returns {string} Generated random value included in devices hash.\n   */\n  getSaltToHashDevices() {\n    if (!this.saltToHashDevices) {\n      throw new AuthError({\n        name: 'EmptyBigIntegersaltToHashDevices',\n        message: 'saltToHashDevices is empty'\n      });\n    }\n    return this.saltToHashDevices;\n  }\n  /**\n   * @returns {string} Value used to verify devices.\n   */\n  getVerifierDevices() {\n    if (!this.verifierDevices) {\n      throw new AuthError({\n        name: 'EmptyBigIntegerVerifierDevices',\n        message: 'verifyDevices is empty'\n      });\n    }\n    return this.verifierDevices;\n  }\n  /**\n   * Generate salts and compute verifier.\n   *\n   * @param {string} deviceGroupKey Devices to generate verifier for.\n   * @param {string} username User to generate verifier for.\n   *\n   * @returns {Promise<void>}\n   */\n  async generateHashDevice(deviceGroupKey, username) {\n    this.randomPassword = getRandomString();\n    const combinedString = `${deviceGroupKey}${username}:${this.randomPassword}`;\n    const hashedString = getHashFromData(combinedString);\n    const hexRandom = getHexFromBytes(getRandomBytes(16));\n    // The random hex will be unambiguously represented as a postive integer\n    this.saltToHashDevices = getPaddedHex(new BigInteger(hexRandom, 16));\n    return new Promise((resolve, reject) => {\n      this.g.modPow(new BigInteger(getHashFromHex(this.saltToHashDevices + hashedString), 16), this.N, (err, result) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        this.verifierDevices = getPaddedHex(result);\n        resolve();\n      });\n    });\n  }\n  /**\n   * Calculates the final HKDF key based on computed S value, computed U value and the key\n   *\n   * @param {String} username Username.\n   * @param {String} password Password.\n   * @param {AuthBigInteger} B Server B value.\n   * @param {AuthBigInteger} salt Generated salt.\n   */\n  async getPasswordAuthenticationKey({\n    username,\n    password,\n    serverBValue,\n    salt\n  }) {\n    if (serverBValue.mod(this.N).equals(BigInteger.ZERO)) {\n      throw new Error('B cannot be zero.');\n    }\n    const U = calculateU({\n      A: this.A,\n      B: serverBValue\n    });\n    const usernamePassword = `${this.userPoolName}${username}:${password}`;\n    const usernamePasswordHash = getHashFromData(usernamePassword);\n    const x = new BigInteger(getHashFromHex(getPaddedHex(salt) + usernamePasswordHash), 16);\n    const S = await calculateS({\n      a: this.a,\n      g: this.g,\n      k: this.k,\n      x,\n      B: serverBValue,\n      N: this.N,\n      U\n    });\n    const context = this.encoder.convert('Caldera Derived Key');\n    const spacer = this.encoder.convert(String.fromCharCode(1));\n    const info = new Uint8Array(context.byteLength + spacer.byteLength);\n    info.set(context, 0);\n    info.set(spacer, context.byteLength);\n    const hkdfKey = getHkdfKey(getBytesFromHex(getPaddedHex(S)), getBytesFromHex(getPaddedHex(U)), info);\n    return hkdfKey;\n  }\n}\nexport { AuthenticationHelper as default };\n//# sourceMappingURL=AuthenticationHelper.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}