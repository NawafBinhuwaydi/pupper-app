{"ast":null,"code":"import _objectSpread from \"/home/nawaf/aws-project/pupper-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ConsoleLogger, createGetCredentialsForIdentityClient } from '@aws-amplify/core';\nimport { assertIdentityPoolIdConfig } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError.mjs';\nimport { getRegionFromIdentityPoolId } from '../../../foundation/parsers/regionParsers.mjs';\nimport { assertIdTokenInAuthTokens } from '../utils/types.mjs';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport { createCognitoIdentityPoolEndpointResolver } from '../factories/createCognitoIdentityPoolEndpointResolver.mjs';\nimport { cognitoIdentityIdProvider } from './IdentityIdProvider.mjs';\nimport { formLoginsMap } from './utils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('CognitoCredentialsProvider');\nconst CREDENTIALS_TTL = 50 * 60 * 1000; // 50 min, can be modified on config if required in the future\nclass CognitoAWSCredentialsAndIdentityIdProvider {\n  constructor(identityIdStore) {\n    this._nextCredentialsRefresh = 0;\n    this._identityIdStore = identityIdStore;\n  }\n  async clearCredentialsAndIdentityId() {\n    logger.debug('Clearing out credentials and identityId');\n    this._credentialsAndIdentityId = undefined;\n    await this._identityIdStore.clearIdentityId();\n  }\n  async clearCredentials() {\n    logger.debug('Clearing out in-memory credentials');\n    this._credentialsAndIdentityId = undefined;\n  }\n  async getCredentialsAndIdentityId(getCredentialsOptions) {\n    const isAuthenticated = getCredentialsOptions.authenticated;\n    const {\n      tokens\n    } = getCredentialsOptions;\n    const {\n      authConfig\n    } = getCredentialsOptions;\n    try {\n      assertIdentityPoolIdConfig(authConfig === null || authConfig === void 0 ? void 0 : authConfig.Cognito);\n    } catch (_unused) {\n      // No identity pool configured, skipping\n      return;\n    }\n    if (!isAuthenticated && !authConfig.Cognito.allowGuestAccess) {\n      // TODO(V6): return partial result like Native platforms\n      return;\n    }\n    const {\n      forceRefresh\n    } = getCredentialsOptions;\n    const tokenHasChanged = this.hasTokenChanged(tokens);\n    const identityId = await cognitoIdentityIdProvider({\n      tokens,\n      authConfig: authConfig.Cognito,\n      identityIdStore: this._identityIdStore\n    });\n    // Clear cached credentials when forceRefresh is true OR the cache token has changed\n    if (forceRefresh || tokenHasChanged) {\n      this.clearCredentials();\n    }\n    if (!isAuthenticated) {\n      return this.getGuestCredentials(identityId, authConfig.Cognito);\n    } else {\n      assertIdTokenInAuthTokens(tokens);\n      return this.credsForOIDCTokens(authConfig.Cognito, tokens, identityId);\n    }\n  }\n  async getGuestCredentials(identityId, authConfig) {\n    var _clientResult, _clientResult2;\n    // Return existing in-memory cached credentials only if it exists, is not past it's lifetime and is unauthenticated credentials\n    if (this._credentialsAndIdentityId && !this.isPastTTL() && this._credentialsAndIdentityId.isAuthenticatedCreds === false) {\n      logger.info('returning stored credentials as they neither past TTL nor expired.');\n      return this._credentialsAndIdentityId;\n    }\n    // Clear to discard if any authenticated credentials are set and start with a clean slate\n    this.clearCredentials();\n    const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n    const getCredentialsForIdentity = createGetCredentialsForIdentityClient({\n      endpointResolver: createCognitoIdentityPoolEndpointResolver({\n        endpointOverride: authConfig.identityPoolEndpoint\n      })\n    });\n    // use identityId to obtain guest credentials\n    // save credentials in-memory\n    // No logins params should be passed for guest creds:\n    // https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html\n    let clientResult;\n    try {\n      clientResult = await getCredentialsForIdentity({\n        region\n      }, {\n        IdentityId: identityId\n      });\n    } catch (e) {\n      assertServiceError(e);\n      throw new AuthError(e);\n    }\n    if ((_clientResult = clientResult) !== null && _clientResult !== void 0 && (_clientResult = _clientResult.Credentials) !== null && _clientResult !== void 0 && _clientResult.AccessKeyId && (_clientResult2 = clientResult) !== null && _clientResult2 !== void 0 && (_clientResult2 = _clientResult2.Credentials) !== null && _clientResult2 !== void 0 && _clientResult2.SecretKey) {\n      this._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n      const res = {\n        credentials: {\n          accessKeyId: clientResult.Credentials.AccessKeyId,\n          secretAccessKey: clientResult.Credentials.SecretKey,\n          sessionToken: clientResult.Credentials.SessionToken,\n          expiration: clientResult.Credentials.Expiration\n        },\n        identityId\n      };\n      if (clientResult.IdentityId) {\n        res.identityId = clientResult.IdentityId;\n        this._identityIdStore.storeIdentityId({\n          id: clientResult.IdentityId,\n          type: 'guest'\n        });\n      }\n      this._credentialsAndIdentityId = _objectSpread(_objectSpread({}, res), {}, {\n        isAuthenticatedCreds: false\n      });\n      return res;\n    } else {\n      throw new AuthError({\n        name: 'CredentialsNotFoundException',\n        message: \"Cognito did not respond with either Credentials, AccessKeyId or SecretKey.\"\n      });\n    }\n  }\n  async credsForOIDCTokens(authConfig, authTokens, identityId) {\n    var _clientResult3, _clientResult4;\n    if (this._credentialsAndIdentityId && !this.isPastTTL() && this._credentialsAndIdentityId.isAuthenticatedCreds === true) {\n      logger.debug('returning stored credentials as they neither past TTL nor expired.');\n      return this._credentialsAndIdentityId;\n    }\n    // Clear to discard if any unauthenticated credentials are set and start with a clean slate\n    this.clearCredentials();\n    const logins = authTokens.idToken ? formLoginsMap(authTokens.idToken.toString()) : {};\n    const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n    const getCredentialsForIdentity = createGetCredentialsForIdentityClient({\n      endpointResolver: createCognitoIdentityPoolEndpointResolver({\n        endpointOverride: authConfig.identityPoolEndpoint\n      })\n    });\n    let clientResult;\n    try {\n      clientResult = await getCredentialsForIdentity({\n        region\n      }, {\n        IdentityId: identityId,\n        Logins: logins\n      });\n    } catch (e) {\n      assertServiceError(e);\n      throw new AuthError(e);\n    }\n    if ((_clientResult3 = clientResult) !== null && _clientResult3 !== void 0 && (_clientResult3 = _clientResult3.Credentials) !== null && _clientResult3 !== void 0 && _clientResult3.AccessKeyId && (_clientResult4 = clientResult) !== null && _clientResult4 !== void 0 && (_clientResult4 = _clientResult4.Credentials) !== null && _clientResult4 !== void 0 && _clientResult4.SecretKey) {\n      var _authTokens$idToken;\n      this._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n      const res = {\n        credentials: {\n          accessKeyId: clientResult.Credentials.AccessKeyId,\n          secretAccessKey: clientResult.Credentials.SecretKey,\n          sessionToken: clientResult.Credentials.SessionToken,\n          expiration: clientResult.Credentials.Expiration\n        },\n        identityId\n      };\n      if (clientResult.IdentityId) {\n        res.identityId = clientResult.IdentityId;\n        // note: the following call removes guest identityId from the persistent store (localStorage)\n        this._identityIdStore.storeIdentityId({\n          id: clientResult.IdentityId,\n          type: 'primary'\n        });\n      }\n      // Store the credentials in-memory along with the expiration\n      this._credentialsAndIdentityId = _objectSpread(_objectSpread({}, res), {}, {\n        isAuthenticatedCreds: true,\n        associatedIdToken: (_authTokens$idToken = authTokens.idToken) === null || _authTokens$idToken === void 0 ? void 0 : _authTokens$idToken.toString()\n      });\n      return res;\n    } else {\n      throw new AuthError({\n        name: 'CredentialsException',\n        message: \"Cognito did not respond with either Credentials, AccessKeyId or SecretKey.\"\n      });\n    }\n  }\n  isPastTTL() {\n    return this._nextCredentialsRefresh === undefined ? true : this._nextCredentialsRefresh <= Date.now();\n  }\n  hasTokenChanged(tokens) {\n    var _this$_credentialsAnd, _tokens$idToken;\n    return !!tokens && !!((_this$_credentialsAnd = this._credentialsAndIdentityId) !== null && _this$_credentialsAnd !== void 0 && _this$_credentialsAnd.associatedIdToken) && ((_tokens$idToken = tokens.idToken) === null || _tokens$idToken === void 0 ? void 0 : _tokens$idToken.toString()) !== this._credentialsAndIdentityId.associatedIdToken;\n  }\n}\nexport { CognitoAWSCredentialsAndIdentityIdProvider };\n//# sourceMappingURL=credentialsProvider.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}