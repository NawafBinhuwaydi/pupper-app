{"ast":null,"code":"import _objectSpread from \"/home/nawaf/aws-project/pupper-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { DEFAULT_RETRY_ATTEMPTS } from './constants.mjs';\n\n/**\n * Middleware that executes the retry logic.\n */\nconst retryMiddlewareFactory = _ref => {\n  let {\n    maxAttempts = DEFAULT_RETRY_ATTEMPTS,\n    retryDecider,\n    computeDelay,\n    abortSignal\n  } = _ref;\n  if (maxAttempts < 1) {\n    throw new Error('maxAttempts must be greater than 0');\n  }\n  return (next, context) => async function retryMiddleware(request) {\n    var _context$attemptsCoun;\n    let error;\n    let attemptsCount = (_context$attemptsCoun = context.attemptsCount) !== null && _context$attemptsCoun !== void 0 ? _context$attemptsCoun : 0;\n    let response;\n    // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n    const handleTerminalErrorOrResponse = () => {\n      if (response) {\n        addOrIncrementMetadataAttempts(response, attemptsCount);\n        return response;\n      } else {\n        addOrIncrementMetadataAttempts(error, attemptsCount);\n        throw error;\n      }\n    };\n    while (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) && attemptsCount < maxAttempts) {\n      var _context$attemptsCoun2, _context$attemptsCoun3;\n      try {\n        response = await next(request);\n        error = undefined;\n      } catch (e) {\n        error = e;\n        response = undefined;\n      }\n      // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n      attemptsCount = ((_context$attemptsCoun2 = context.attemptsCount) !== null && _context$attemptsCoun2 !== void 0 ? _context$attemptsCoun2 : 0) > attemptsCount ? (_context$attemptsCoun3 = context.attemptsCount) !== null && _context$attemptsCoun3 !== void 0 ? _context$attemptsCoun3 : 0 : attemptsCount + 1;\n      context.attemptsCount = attemptsCount;\n      const {\n        isCredentialsExpiredError,\n        retryable\n      } = await retryDecider(response, error, context);\n      if (retryable) {\n        // Setting isCredentialsInvalid flag to notify signing middleware to forceRefresh credentials provider.\n        context.isCredentialsExpired = !!isCredentialsExpiredError;\n        if (!(abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) && attemptsCount < maxAttempts) {\n          // prevent sleep for last attempt or cancelled request;\n          const delay = computeDelay(attemptsCount);\n          await cancellableSleep(delay, abortSignal);\n        }\n        continue;\n      } else {\n        return handleTerminalErrorOrResponse();\n      }\n    }\n    if (abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) {\n      throw new Error('Request aborted.');\n    } else {\n      return handleTerminalErrorOrResponse();\n    }\n  };\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n  if (abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) {\n    return Promise.resolve();\n  }\n  let timeoutId;\n  let sleepPromiseResolveFn;\n  const sleepPromise = new Promise(resolve => {\n    sleepPromiseResolveFn = resolve;\n    timeoutId = setTimeout(resolve, timeoutMs);\n  });\n  abortSignal === null || abortSignal === void 0 || abortSignal.addEventListener('abort', function cancelSleep(_) {\n    clearTimeout(timeoutId);\n    abortSignal === null || abortSignal === void 0 || abortSignal.removeEventListener('abort', cancelSleep);\n    sleepPromiseResolveFn();\n  });\n  return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n  var _nextHandlerOutput$$m;\n  if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n    return;\n  }\n  nextHandlerOutput.$metadata = _objectSpread(_objectSpread({}, (_nextHandlerOutput$$m = nextHandlerOutput.$metadata) !== null && _nextHandlerOutput$$m !== void 0 ? _nextHandlerOutput$$m : {}), {}, {\n    attempts\n  });\n};\nexport { retryMiddlewareFactory };\n//# sourceMappingURL=retryMiddleware.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}