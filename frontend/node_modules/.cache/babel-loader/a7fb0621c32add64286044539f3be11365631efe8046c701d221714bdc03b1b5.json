{"ast":null,"code":"import _objectSpread from \"/home/nawaf/aws-project/pupper-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nfunction isAmplifyOutputs(config) {\n  // version format initially will be '1' but is expected to be something like x.y where x is major and y minor version\n  const {\n    version\n  } = config;\n  if (!version) {\n    return false;\n  }\n  return version.startsWith('1');\n}\nfunction parseStorage(amplifyOutputsStorageProperties) {\n  if (!amplifyOutputsStorageProperties) {\n    return undefined;\n  }\n  const {\n    bucket_name,\n    aws_region,\n    buckets\n  } = amplifyOutputsStorageProperties;\n  return {\n    S3: {\n      bucket: bucket_name,\n      region: aws_region,\n      buckets: buckets && createBucketInfoMap(buckets)\n    }\n  };\n}\nfunction parseAuth(amplifyOutputsAuthProperties) {\n  if (!amplifyOutputsAuthProperties) {\n    return undefined;\n  }\n  const {\n    user_pool_id,\n    user_pool_client_id,\n    identity_pool_id,\n    password_policy,\n    mfa_configuration,\n    mfa_methods,\n    unauthenticated_identities_enabled,\n    oauth,\n    username_attributes,\n    standard_required_attributes,\n    groups\n  } = amplifyOutputsAuthProperties;\n  const authConfig = {\n    Cognito: {\n      userPoolId: user_pool_id,\n      userPoolClientId: user_pool_client_id,\n      groups\n    }\n  };\n  if (identity_pool_id) {\n    authConfig.Cognito = _objectSpread(_objectSpread({}, authConfig.Cognito), {}, {\n      identityPoolId: identity_pool_id\n    });\n  }\n  if (password_policy) {\n    var _password_policy$min_;\n    authConfig.Cognito.passwordFormat = {\n      requireLowercase: password_policy.require_lowercase,\n      requireNumbers: password_policy.require_numbers,\n      requireUppercase: password_policy.require_uppercase,\n      requireSpecialCharacters: password_policy.require_symbols,\n      minLength: (_password_policy$min_ = password_policy.min_length) !== null && _password_policy$min_ !== void 0 ? _password_policy$min_ : 6\n    };\n  }\n  if (mfa_configuration) {\n    authConfig.Cognito.mfa = {\n      status: getMfaStatus(mfa_configuration),\n      smsEnabled: mfa_methods === null || mfa_methods === void 0 ? void 0 : mfa_methods.includes('SMS'),\n      totpEnabled: mfa_methods === null || mfa_methods === void 0 ? void 0 : mfa_methods.includes('TOTP')\n    };\n  }\n  if (unauthenticated_identities_enabled) {\n    authConfig.Cognito.allowGuestAccess = unauthenticated_identities_enabled;\n  }\n  if (oauth) {\n    authConfig.Cognito.loginWith = {\n      oauth: {\n        domain: oauth.domain,\n        redirectSignIn: oauth.redirect_sign_in_uri,\n        redirectSignOut: oauth.redirect_sign_out_uri,\n        responseType: oauth.response_type === 'token' ? 'token' : 'code',\n        scopes: oauth.scopes,\n        providers: getOAuthProviders(oauth.identity_providers)\n      }\n    };\n  }\n  if (username_attributes) {\n    authConfig.Cognito.loginWith = _objectSpread(_objectSpread({}, authConfig.Cognito.loginWith), {}, {\n      email: username_attributes.includes('email'),\n      phone: username_attributes.includes('phone_number'),\n      // Signing in with a username is not currently supported in Gen2, this should always evaluate to false\n      username: username_attributes.includes('username')\n    });\n  }\n  if (standard_required_attributes) {\n    authConfig.Cognito.userAttributes = standard_required_attributes.reduce((acc, curr) => _objectSpread(_objectSpread({}, acc), {}, {\n      [curr]: {\n        required: true\n      }\n    }), {});\n  }\n  return authConfig;\n}\nfunction parseAnalytics(amplifyOutputsAnalyticsProperties) {\n  if (!(amplifyOutputsAnalyticsProperties !== null && amplifyOutputsAnalyticsProperties !== void 0 && amplifyOutputsAnalyticsProperties.amazon_pinpoint)) {\n    return undefined;\n  }\n  const {\n    amazon_pinpoint\n  } = amplifyOutputsAnalyticsProperties;\n  return {\n    Pinpoint: {\n      appId: amazon_pinpoint.app_id,\n      region: amazon_pinpoint.aws_region\n    }\n  };\n}\nfunction parseGeo(amplifyOutputsAnalyticsProperties) {\n  if (!amplifyOutputsAnalyticsProperties) {\n    return undefined;\n  }\n  const {\n    aws_region,\n    geofence_collections,\n    maps,\n    search_indices\n  } = amplifyOutputsAnalyticsProperties;\n  return {\n    LocationService: {\n      region: aws_region,\n      searchIndices: search_indices,\n      geofenceCollections: geofence_collections,\n      maps\n    }\n  };\n}\nfunction parseData(amplifyOutputsDataProperties) {\n  if (!amplifyOutputsDataProperties) {\n    return undefined;\n  }\n  const {\n    aws_region,\n    default_authorization_type,\n    url,\n    api_key,\n    model_introspection\n  } = amplifyOutputsDataProperties;\n  const GraphQL = {\n    endpoint: url,\n    defaultAuthMode: getGraphQLAuthMode(default_authorization_type),\n    region: aws_region,\n    apiKey: api_key,\n    modelIntrospection: model_introspection\n  };\n  return {\n    GraphQL\n  };\n}\nfunction parseCustom(amplifyOutputsCustomProperties) {\n  if (!(amplifyOutputsCustomProperties !== null && amplifyOutputsCustomProperties !== void 0 && amplifyOutputsCustomProperties.events)) {\n    return undefined;\n  }\n  const {\n    url,\n    aws_region,\n    api_key,\n    default_authorization_type\n  } = amplifyOutputsCustomProperties.events;\n  const Events = {\n    endpoint: url,\n    defaultAuthMode: getGraphQLAuthMode(default_authorization_type),\n    region: aws_region,\n    apiKey: api_key\n  };\n  return {\n    Events\n  };\n}\nfunction parseNotifications(amplifyOutputsNotificationsProperties) {\n  if (!amplifyOutputsNotificationsProperties) {\n    return undefined;\n  }\n  const {\n    aws_region,\n    channels,\n    amazon_pinpoint_app_id\n  } = amplifyOutputsNotificationsProperties;\n  const hasInAppMessaging = channels.includes('IN_APP_MESSAGING');\n  const hasPushNotification = channels.includes('APNS') || channels.includes('FCM');\n  if (!(hasInAppMessaging || hasPushNotification)) {\n    return undefined;\n  }\n  // At this point, we know the Amplify outputs contains at least one supported channel\n  const notificationsConfig = {};\n  if (hasInAppMessaging) {\n    notificationsConfig.InAppMessaging = {\n      Pinpoint: {\n        appId: amazon_pinpoint_app_id,\n        region: aws_region\n      }\n    };\n  }\n  if (hasPushNotification) {\n    notificationsConfig.PushNotification = {\n      Pinpoint: {\n        appId: amazon_pinpoint_app_id,\n        region: aws_region\n      }\n    };\n  }\n  return notificationsConfig;\n}\nfunction parseAmplifyOutputs(amplifyOutputs) {\n  const resourcesConfig = {};\n  if (amplifyOutputs.storage) {\n    resourcesConfig.Storage = parseStorage(amplifyOutputs.storage);\n  }\n  if (amplifyOutputs.auth) {\n    resourcesConfig.Auth = parseAuth(amplifyOutputs.auth);\n  }\n  if (amplifyOutputs.analytics) {\n    resourcesConfig.Analytics = parseAnalytics(amplifyOutputs.analytics);\n  }\n  if (amplifyOutputs.geo) {\n    resourcesConfig.Geo = parseGeo(amplifyOutputs.geo);\n  }\n  if (amplifyOutputs.data) {\n    resourcesConfig.API = parseData(amplifyOutputs.data);\n  }\n  if (amplifyOutputs.custom) {\n    const customConfig = parseCustom(amplifyOutputs.custom);\n    if (customConfig && 'Events' in customConfig) {\n      resourcesConfig.API = _objectSpread(_objectSpread({}, resourcesConfig.API), customConfig);\n    }\n  }\n  if (amplifyOutputs.notifications) {\n    resourcesConfig.Notifications = parseNotifications(amplifyOutputs.notifications);\n  }\n  return resourcesConfig;\n}\nconst authModeNames = {\n  AMAZON_COGNITO_USER_POOLS: 'userPool',\n  API_KEY: 'apiKey',\n  AWS_IAM: 'iam',\n  AWS_LAMBDA: 'lambda',\n  OPENID_CONNECT: 'oidc'\n};\nfunction getGraphQLAuthMode(authType) {\n  return authModeNames[authType];\n}\nconst providerNames = {\n  GOOGLE: 'Google',\n  LOGIN_WITH_AMAZON: 'Amazon',\n  FACEBOOK: 'Facebook',\n  SIGN_IN_WITH_APPLE: 'Apple'\n};\nfunction getOAuthProviders() {\n  let providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return providers.reduce((oAuthProviders, provider) => {\n    if (providerNames[provider] !== undefined) {\n      oAuthProviders.push(providerNames[provider]);\n    }\n    return oAuthProviders;\n  }, []);\n}\nfunction getMfaStatus(mfaConfiguration) {\n  if (mfaConfiguration === 'OPTIONAL') return 'optional';\n  if (mfaConfiguration === 'REQUIRED') return 'on';\n  return 'off';\n}\nfunction createBucketInfoMap(buckets) {\n  const mappedBuckets = {};\n  buckets.forEach(_ref => {\n    let {\n      name,\n      bucket_name: bucketName,\n      aws_region: region,\n      paths\n    } = _ref;\n    if (name in mappedBuckets) {\n      throw new Error(\"Duplicate friendly name found: \".concat(name, \". Name must be unique.\"));\n    }\n    const sanitizedPaths = paths ? Object.entries(paths).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      if (value !== undefined) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {}) : undefined;\n    mappedBuckets[name] = {\n      bucketName,\n      region,\n      paths: sanitizedPaths\n    };\n  });\n  return mappedBuckets;\n}\nexport { isAmplifyOutputs, parseAmplifyOutputs, parseAnalytics };\n//# sourceMappingURL=parseAmplifyOutputs.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}