{"ast":null,"code":"import { DEFAULT_RETRY_ATTEMPTS } from './constants.mjs';\n\n/**\n * Middleware that executes the retry logic.\n */\nconst retryMiddlewareFactory = ({\n  maxAttempts = DEFAULT_RETRY_ATTEMPTS,\n  retryDecider,\n  computeDelay,\n  abortSignal\n}) => {\n  if (maxAttempts < 1) {\n    throw new Error('maxAttempts must be greater than 0');\n  }\n  return (next, context) => async function retryMiddleware(request) {\n    let error;\n    let attemptsCount = context.attemptsCount ?? 0;\n    let response;\n    // When retry is not needed or max attempts is reached, either error or response will be set. This function handles either cases.\n    const handleTerminalErrorOrResponse = () => {\n      if (response) {\n        addOrIncrementMetadataAttempts(response, attemptsCount);\n        return response;\n      } else {\n        addOrIncrementMetadataAttempts(error, attemptsCount);\n        throw error;\n      }\n    };\n    while (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n      try {\n        response = await next(request);\n        error = undefined;\n      } catch (e) {\n        error = e;\n        response = undefined;\n      }\n      // context.attemptsCount may be updated after calling next handler which may retry the request by itself.\n      attemptsCount = (context.attemptsCount ?? 0) > attemptsCount ? context.attemptsCount ?? 0 : attemptsCount + 1;\n      context.attemptsCount = attemptsCount;\n      const {\n        isCredentialsExpiredError,\n        retryable\n      } = await retryDecider(response, error, context);\n      if (retryable) {\n        // Setting isCredentialsInvalid flag to notify signing middleware to forceRefresh credentials provider.\n        context.isCredentialsExpired = !!isCredentialsExpiredError;\n        if (!abortSignal?.aborted && attemptsCount < maxAttempts) {\n          // prevent sleep for last attempt or cancelled request;\n          const delay = computeDelay(attemptsCount);\n          await cancellableSleep(delay, abortSignal);\n        }\n        continue;\n      } else {\n        return handleTerminalErrorOrResponse();\n      }\n    }\n    if (abortSignal?.aborted) {\n      throw new Error('Request aborted.');\n    } else {\n      return handleTerminalErrorOrResponse();\n    }\n  };\n};\nconst cancellableSleep = (timeoutMs, abortSignal) => {\n  if (abortSignal?.aborted) {\n    return Promise.resolve();\n  }\n  let timeoutId;\n  let sleepPromiseResolveFn;\n  const sleepPromise = new Promise(resolve => {\n    sleepPromiseResolveFn = resolve;\n    timeoutId = setTimeout(resolve, timeoutMs);\n  });\n  abortSignal?.addEventListener('abort', function cancelSleep(_) {\n    clearTimeout(timeoutId);\n    abortSignal?.removeEventListener('abort', cancelSleep);\n    sleepPromiseResolveFn();\n  });\n  return sleepPromise;\n};\nconst addOrIncrementMetadataAttempts = (nextHandlerOutput, attempts) => {\n  if (Object.prototype.toString.call(nextHandlerOutput) !== '[object Object]') {\n    return;\n  }\n  nextHandlerOutput.$metadata = {\n    ...(nextHandlerOutput.$metadata ?? {}),\n    attempts\n  };\n};\nexport { retryMiddlewareFactory };\n//# sourceMappingURL=retryMiddleware.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}