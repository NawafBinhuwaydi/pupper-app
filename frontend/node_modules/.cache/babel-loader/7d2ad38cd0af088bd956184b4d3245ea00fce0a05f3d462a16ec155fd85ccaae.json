{"ast":null,"code":"import { AmplifyUrl, USER_AGENT_HEADER, urlSafeDecode, AMPLIFY_SYMBOL } from '@aws-amplify/core/internals/utils';\nimport { decodeJWT, Hub } from '@aws-amplify/core';\nimport { cacheCognitoTokens } from '../../tokenProvider/cacheTokens.mjs';\nimport { dispatchSignedInHubEvent } from '../dispatchSignedInHubEvent.mjs';\nimport '../refreshAuthTokens.mjs';\nimport '../../tokenProvider/errorHelpers.mjs';\nimport { oAuthStore } from './oAuthStore.mjs';\nimport { resolveAndClearInflightPromises } from './inflightPromise.mjs';\nimport { tokenOrchestrator } from '../../tokenProvider/tokenProvider.mjs';\nimport { createOAuthError } from './createOAuthError.mjs';\nimport { validateState } from './validateState.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst completeOAuthFlow = async ({\n  currentUrl,\n  userAgentValue,\n  clientId,\n  redirectUri,\n  responseType,\n  domain,\n  preferPrivateSession\n}) => {\n  const urlParams = new AmplifyUrl(currentUrl);\n  const error = urlParams.searchParams.get('error');\n  const errorMessage = urlParams.searchParams.get('error_description');\n  if (error) {\n    throw createOAuthError(errorMessage ?? error);\n  }\n  if (responseType === 'code') {\n    return handleCodeFlow({\n      currentUrl,\n      userAgentValue,\n      clientId,\n      redirectUri,\n      domain,\n      preferPrivateSession\n    });\n  }\n  return handleImplicitFlow({\n    currentUrl,\n    redirectUri,\n    preferPrivateSession\n  });\n};\nconst handleCodeFlow = async ({\n  currentUrl,\n  userAgentValue,\n  clientId,\n  redirectUri,\n  domain,\n  preferPrivateSession\n}) => {\n  /* Convert URL into an object with parameters as keys\n  { redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n  const url = new AmplifyUrl(currentUrl);\n  const code = url.searchParams.get('code');\n  const state = url.searchParams.get('state');\n  // if `code` or `state` is not presented in the redirect url, most likely\n  // that the end user cancelled the inflight oauth flow by:\n  // 1. clicking the back button of browser\n  // 2. closing the provider hosted UI page and coming back to the app\n  if (!code || !state) {\n    throw createOAuthError('User cancelled OAuth flow.');\n  }\n  // may throw error is being caught in attemptCompleteOAuthFlow.ts\n  const validatedState = await validateState(state);\n  const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n  // TODO(v6): check hub events\n  // dispatchAuthEvent(\n  // \t'codeFlow',\n  // \t{},\n  // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n  // );\n  const codeVerifier = await oAuthStore.loadPKCE();\n  const oAuthTokenBody = {\n    grant_type: 'authorization_code',\n    code,\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    ...(codeVerifier ? {\n      code_verifier: codeVerifier\n    } : {})\n  };\n  const body = Object.entries(oAuthTokenBody).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  const {\n    access_token,\n    refresh_token: refreshToken,\n    id_token,\n    error,\n    error_message: errorMessage,\n    token_type,\n    expires_in\n  } = await (await fetch(oAuthTokenEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      [USER_AGENT_HEADER]: userAgentValue\n    },\n    body\n  })).json();\n  if (error) {\n    // error is being caught in attemptCompleteOAuthFlow.ts\n    throw createOAuthError(errorMessage ?? error);\n  }\n  const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    RefreshToken: refreshToken\n  });\n  return completeFlow({\n    redirectUri,\n    state: validatedState,\n    preferPrivateSession\n  });\n};\nconst handleImplicitFlow = async ({\n  currentUrl,\n  redirectUri,\n  preferPrivateSession\n}) => {\n  // hash is `null` if `#` doesn't exist on URL\n  const url = new AmplifyUrl(currentUrl);\n  const {\n    id_token,\n    access_token,\n    state,\n    token_type,\n    expires_in,\n    error_description,\n    error\n  } = (url.hash ?? '#').substring(1) // Remove # from returned code\n  .split('&').map(pairings => pairings.split('=')).reduce((accum, [k, v]) => ({\n    ...accum,\n    [k]: v\n  }), {\n    id_token: undefined,\n    access_token: undefined,\n    state: undefined,\n    token_type: undefined,\n    expires_in: undefined,\n    error_description: undefined,\n    error: undefined\n  });\n  if (error) {\n    throw createOAuthError(error_description ?? error);\n  }\n  if (!access_token) {\n    // error is being caught in attemptCompleteOAuthFlow.ts\n    throw createOAuthError('No access token returned from OAuth flow.');\n  }\n  const validatedState = await validateState(state);\n  const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token\n  });\n  return completeFlow({\n    redirectUri,\n    state: validatedState,\n    preferPrivateSession\n  });\n};\nconst completeFlow = async ({\n  redirectUri,\n  state,\n  preferPrivateSession\n}) => {\n  await tokenOrchestrator.setOAuthMetadata({\n    oauthSignIn: true\n  });\n  await oAuthStore.clearOAuthData();\n  await oAuthStore.storeOAuthSignIn(true, preferPrivateSession);\n  // this should be called before any call that involves `fetchAuthSession`\n  // e.g. `getCurrentUser()` below, so it allows every inflight async calls to\n  //  `fetchAuthSession` can be resolved\n  resolveAndClearInflightPromises();\n  // clear history before sending out final Hub events\n  clearHistory(redirectUri);\n  if (isCustomState(state)) {\n    Hub.dispatch('auth', {\n      event: 'customOAuthState',\n      data: urlSafeDecode(getCustomState(state))\n    }, 'Auth', AMPLIFY_SYMBOL);\n  }\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect'\n  }, 'Auth', AMPLIFY_SYMBOL);\n  await dispatchSignedInHubEvent();\n};\nconst isCustomState = state => {\n  return /-/.test(state);\n};\nconst getCustomState = state => {\n  return state.split('-').splice(1).join('-');\n};\nconst clearHistory = redirectUri => {\n  if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n    window.history.replaceState(window.history.state, '', redirectUri);\n  }\n};\nexport { completeOAuthFlow };\n//# sourceMappingURL=completeOAuthFlow.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}